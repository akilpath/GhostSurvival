#------------------------------------------------------------------
# Name:        Ghost Surivval
# Purpose:     ICS3U Final Project
#
# Author:      Akil Pathiranage
# Created:     March 18th, 2021
# Updated:     April 2nd, 2021
#------------------------------------------------------------------
#I think this project deserves a level 4+ because
# I explored a completely new engine that we haven't learned in class.
# I created this game within two weeks and I had to learn a lot of new concepts
# I added sound effects and did movement in 3d, which is something we did not do in class
# I not only used regular classes but inheritance as well. 
#Features Added:
#   Sound effects
#   Support across multiple framerates
#   Collision detection between ghosts, player and axe
#   Microbit support
#   Ability to save settings
#------------------------------------------------------------------

#make sure panda3d is installed into Thonny
#responsible for loading the configurations of panda3d
from panda3d.core import loadPrcFile
loadPrcFile("config/conf.prc")

from direct.showbase.ShowBase import ShowBase
from direct.showbase import Audio3DManager

from event_handling import Handler
from window_properties import GameProperties

from panda3d.core import PointLight
from panda3d.core import AmbientLight
from panda3d.core import Material
from panda3d.core import NodePath
from panda3d.core import CollisionTraverser


from player import Player
from ghost import Ghost
from timer import Timer
from settings import Settings

from direct.gui.DirectGui import *
from panda3d.core import TransparencyAttrib
from panda3d.core import TextNode
from microbit import Microbit

import webbrowser
import game
import sys
import math

#Assets grabbed from: 
# Trees and axe from: https://jhan-gutierrez.itch.io/low-poly-cabin
# Ghost model from: https://www.cgtrader.com/items/2635022/download-page#
# Font from: https://www.1001freefonts.com/mrs-monster.font
# Ghost hit Sound effect from: https://mixkit.co/free-sound-effects/game/
# Music from: https://soundimage.org/horrorsurreal/

#Learned Engine from:
# https://docs.panda3d.org/1.10/python/index
# https://www.youtube.com/channel/UC4L3JyeL7TXQM1f3yD6iVQQ

#Microbit implementation taken from Mr.Brooks
class MyGame(ShowBase):
    def __init__(self):
        '''
        Main Game class, contains all global attributes as well as object within the game.
        It inherits from the Showbase class of panda3d, which is the main class containing all the basic methods, functions and attributes
        of the scene in panda3d.
        When any instance of ShowBase() is created, it generates the scene graph along with some basic parts of panda3d necessary such as the
        scene graph (self.render), the task manager and the collision traverser (cTrav). This class takes no parameters and returns nothing,
        this class can be thought of as the main game.

        Key Concepts:
        
        Task Manager 
        ----------------------------------------------------
        Task manager (taskMgr) is the part of panda3d that is called every frame. Instead of the game having a main loop where you put your code inside,
        You add methods/functions to the task manager which get called every frame or however you specify it to be called. Each method that is called by
        Task manager requires a parameter that accepts the task object, and whenever a task method is finished, it needs to return task.cont, task.done or task.again.
        
        
        Scene Graph:
        ----------------------------------------------------
        The scene graph is what Panda3D uses to render models and 2d images/text. The scene graph is created when an instance of ShowBase() is created. At the top
        of the scene graph, you have "render". Everything in 3d that you want to put into the scene needs to be a child of self.render . Each frame, the scene is being drawn from the top of the scene graph.
        There are other scene graphs such as render2d and aspect2d (these two allow for you to place 2d models that will be drawn on top of the 3d screen).
        A more in depth explanation of the scene graph can be found here: https://docs.panda3d.org/1.10/python/programming/scene-graph/index
        
        Collision Traverser:
        ----------------------------------------------------
        Collision traversers are objects that check for collisions between collision solids (collision system of panda3d). The only collision traverser that I use is the main one
        generated by panda3d, called cTrav. This is a collision traverser that is automatically part of the task manager. More information about collision traversers can be found here:
        https://docs.panda3d.org/1.10/python/programming/collision-detection/collision-traversers
        
        Parameters
        ----------------------------------------------------
        None
        
        Returns
        ----------------------------------------------------
        None
        
        
'''
        game.gameObj = self
        super().__init__()
        self.set_background_color(0,0,0)
        
        self.settings = Settings()
        self.inputMode = self.settings.input
        self.gameRoot = NodePath("gameroot")
        self.gameRoot.reparentTo(self.render)
        self.sensX = self.settings.sensitivityX
        self.sensY = self.settings.sensitivityY
        self.gameFont = self.loader.loadFont(r"assets/mrsmonster.ttf")
        
        #Lighting
        plight = PointLight('my dlight')
        self.pLight = self.render.attachNewNode(plight)
        self.pLight.setPos(0,0,20)
        alight = AmbientLight("alight")
        alight.setColor((0.2,0.2,0.2,1))
        self.aLight = self.gameRoot.attachNewNode(alight)
        
        #If the input mode is microbit, it checks if a microbit is connected, if not it defaults to the regular mouse input.
        if self.inputMode == "microbit":
            try:
                self.microbit = Microbit()
            except Exception as e:
                print(e)
                self.inputMode = "mouse"
        
        #ghost model instance, all ghosts created reference this model
        self.globalGhost = self.loader.loadModel(r"assets/ghost.bam")
        self.globalGhost.setScale(0.5)
        self.globalGhost.setLight(self.aLight)
        self.globalGhost.setLight(self.pLight)
        
        #Sound effects and music
        self.globalGhostHitSFX = self.loader.loadSfx(r"assets/sounds/mixkit-boxing-punch-2051.wav")
        self.globalGhostDeathSFX = self.loader.loadSfx(r"assets/sounds/mixkit-martial-arts-fast-punch-2047.wav")
        self.globalGhostHitSFX.setVolume(0.75)
        self.introMusic = self.loader.loadMusic(r"assets/sounds/Horror-Game-Intro.mp3")
        self.introMusic.setLoop(True)
        self.inGameMusic = self.loader.loadMusic(r"assets/sounds/Wicked-Dreams.mp3")
        self.inGameMusic.setLoop(True)
        self.inGameMusic.setVolume(0.1)
        
        #window properties configuration
        #disableMouse() disables the original mouse control that comes with panda3d (does not disable the mouse itself)
        self.disableMouse()
        self.events = Handler()
        self.windowProps = GameProperties()
        self.win.requestProperties(self.windowProps)
        
        self.ghostKills = 0
        self.dt = 0.0
        self.mapBorder = ((-57,45),(-26,34))
        self.textures = None
        self.environment = None
        self.round = None
        self.ghosts = None
        self.player = None
        self.props = None
        self.roundSpawnTimer = None
        self.gui = None
        self.roundCounter = None
        
        self.taskMgr.add(self.escapeQuit,"quitGame")
        self.taskMgr.add(self.setUpStartScreen, "startScreenSetup")
        
    def updateMicrobit(self, task):
        '''
        This is a task that is reponsible for translating the microbit into an event (see Handler class). This reads the most recent line from the microbit,
        then passes it through the translateMicrobitEvent method of the Handler class, which throws an event depending on what data is coming from the microbit.
        This is a task that is added to the taskmanager only if there is a microbit and the input mode is set to microbit.
        
        Parameters
        ----------------------------------------------------
        task: task object from direct.task
        
        Returns
        ----------------------------------------------------
        Returns task.cont, which indicates this task is finished. 

'''
        data = self.microbit.readRecentLine()
        self.events.translateMicrobitEvent(data)
        return task.cont

    def openBrowser(self):
        '''Method that opens the webbrowser'''
        webbrowser.open("https://docs.google.com/document/d/1td1yljKY49hl_4uXnuGlYh4GG2xHg8Q5RKU-7CC7eqs/edit?usp=sharing")
        
    def changeInput(self, state):
        '''
        This method is called by the microbit button in the settings screened, it passes in the current state that the button is in.
        This is used as a way for the user to change their input method in the settings. If the state is 1, it sets the input to microbit,
        if the state is 0, it sets the input to mouse. It then updates the settings object of the main Game. 
        
        Parameters
        ----------------------------------------------------
        state: an integer, either one or zero representing the state of the microbit button (DirectCheckButton object)
        
        Returns
        ----------------------------------------------------
        None
'''
        if state == 1:
            self.inputMode = "microbit"
        if state == 0:
            self.inputMode = "mouse"
        self.settings.update(inputIn = self.inputMode)
    
    def updateSensitivity(self):
        '''
        This is a method called by both of the sensitivity sliders in settings screen. Each time the slider is changed, it updates
        the sensitivity left and right (x) and the sensivitiy in the up and down (y). It changes the sensitivity text on the
        sensitivity labels to match the slider and also updates the settings object.
        
        Parameters
        ----------------------------------------------------
        None
        
        Returns
        ----------------------------------------------------
        None
'''
        #Elements that are part of the start screen or settings screen get put in the gui dictionary.
        self.sensX = self.gui["sensitivityX"]["value"]*14.4
        self.gui["sensitivityXText"].setText(f"Mouse Sensitivity X: {round(self.sensX/14.4)}")
        self.sensY = self.gui["sensitivityY"]["value"]*14.4
        self.gui["sensitivityYText"].setText(f"Mouse Sensitivity Y: {round(self.sensY/14.4)}")
        self.settings.update(sensXIn = self.sensX, sensYIn = self.sensY)
        
    def transitionStartToSettings(self):
        '''
        This is a method called when transitioning between the start and the settings (called by the settings button
        in the start screen). This method removes the start screen gui and then creates the settings gui.
        
        Parameters
        ----------------------------------------------------
        None
        
        Returns
        ----------------------------------------------------
        None
'''
        for directGui in self.gui.values():
            directGui.destroy()
        self.gui = {"back" : DirectButton(text = "back", scale = 0.1, pos = (-1.5, 0 ,-0.85), command = self.transitionSettingsToStart, text_font = self.gameFont, text_fg = (1,1,1,1), relief = None),
                         "input" : DirectCheckButton(text = "microbit", scale = 0.2, pos = (-0.60,0,0.65), command = self.changeInput, text_font = self.gameFont, text_fg = (1,1,1,1), relief = None),
                         "sensitivityXText" : DirectLabel(text = f"Mouse Sensitivity X: {round(self.sensX/14.4)}", scale = 0.10, pos = (-0.6,0,0.45), text_font = self.gameFont, text_fg = (1,1,1,1), relief = None),
                         "sensitivityX": DirectSlider(scale = 0.5, pos = (-0.6,0,0.4), range = (1,100), value = round(self.sensX/14.4), command = self.updateSensitivity),
                         "sensitivityYText" : DirectLabel(text = f"Mouse Sensitivity Y: {round(self.sensY/14.4)}", scale = 0.10, pos = (-0.6,0,0.25), text_font = self.gameFont, text_fg = (1,1,1,1), relief = None),
                         "sensitivityY": DirectSlider(scale = 0.5, pos = (-0.6,0,0.2), range = (1,100), value = round(self.sensY/14.4), command = self.updateSensitivity)}
        
    def transitionSettingsToStart(self):
        '''
        This method is responsible for transitioning between the settings screen back to the start screen. It is called when
        the user hits the back button on the gui. It removes all the objects on the gui currently, then it adds a task to the
        task manager called startScreenSetup which creates the gui for the start screen.
        
        Parameters
        ----------------------------------------------------
        None
        
        Returns
        ----------------------------------------------------
        None
'''
        for directGui in self.gui.values():
            directGui.destroy()
        self.taskMgr.add(self.setUpStartScreen, "startScreenSetup")
        
    def setUpStartScreen(self, task):
        '''
        This is a task that is reponsible for creating the gui of the start screen, it is the second task that is added to the game,
        it creates the gui for the start screen and also plays the start screen music.
        
        Parameters
        ----------------------------------------------------
        Task: task object from direct.task
        
        Returns
        ----------------------------------------------------
        returns task.done, which indicates the task is finished and should be removed from the task manager.
'''
        self.gui = {"title": DirectLabel(text = "Ghost Survival", scale = 0.3, text_font = self.gameFont, text_fg = (1,1,1,1), relief = None),
                         "start" : DirectButton(text = "Start", scale = 0.2, command = self.transitionStartToGame, text_font = self.gameFont, relief = None, text_fg = (1,0,0,1)),
                         "settings" : DirectButton(text = "Settings", scale = 0.1, command = self.transitionStartToSettings, text_font = self.gameFont, relief = None, text_fg = (1,0,0,1)),
                         "quit" : DirectButton(text = "Quit", scale = 0.1, command = self.gameQuit, text_font = self.gameFont, relief = None, text_fg = (1,0,0,1)),
                         "tutorial" : DirectButton(text = "How To Play", scale = 0.1, command = self.openBrowser, text_font = self.gameFont, text_fg = (1,0,0,1), relief = None)}
        self.gui["title"].setPos(0,0,0.5)
        self.gui["start"].setPos(0,0,0)
        self.gui["settings"].setPos(1.5,0,-0.75)
        self.gui["quit"].setPos(-1.5,-0,-0.75)
        self.gui["tutorial"].setPos(0,0,-0.75)
        self.introMusic.play()
        return task.done
    
    def transitionStartToGame(self):
        '''
        This is a method called when the user clicks the play button in the start screen, it removes the anything on the screen, then adds the task setUpMainGame to the task manager.
        It also stops playing the intro music and starts playing the in game music.
        
        Parameters
        ----------------------------------------------------
        None
        
        Returns
        ----------------------------------------------------
        None
'''
        for thing in self.gui.values():
            thing.destroy()
        self.taskMgr.add(self.setUpMainGame, "setUpMainGame")
        self.introMusic.stop()
        self.inGameMusic.play()
    
    def escapeQuit(self, task):
        '''
        This is a task that is always added to the game. It is the first task that is added to the task manager. This task allows the user to press escape
        at anytime in the program to quit the game. If the user presses escape, it calls the gameQuit method which closes the game.
        
        Parameters
        ----------------------------------------------------
        task: task object from direct.task
        
        Returns
        ----------------------------------------------------
        Returns task.cont which indicates that the task is finished.
'''
        if self.events.keyMap["escape"]:
            self.gameQuit()
        return task.cont
    
    def setUpMainGame(self,task):
        '''
        This method sets up the main game. It loads all the necessary models, creates the map and creates all the objects needed
        for the game.
        
        Parameters
        ----------------------------------------------------
        task: task object from direct.task
        
        Returns
        ----------------------------------------------------
        returns task.done which indicates that the task is finished and should be removed from the task manager

'''
        
        #Changes the cursor from visible to hidden
        #Updates the window properties
        #Assigns a new variable called self.props to the s
        self.windowProps.updateMouseView()
        self.win.requestProperties(self.windowProps)
        self.props = self.win.getProperties()
        
        #Resets the event handling object and also initializes the collision traverser. 
        self.events = Handler()
        self.cTrav = CollisionTraverser("mainTraverser")
        
        #Loads textures for the axe and the trees.
        #self.environment is the floor of the world
        #inserts the floor into the scene graph and sets its position and color
        #Colors are done in percent of rgb, instead of having a color being from 0-255, it is 0-1
        self.textures = self.loader.loadTexture(r"assets/tex/colorPalette.png")
        self.environment = self.loader.loadModel(r"assets/environment.egg")
        self.environment.reparentTo(self.gameRoot)
        self.environment.setPos(0,0,-1)
        self.environment.setColor(0.0706,0.4,0.149)
        
        #sets the round equal to one and resets the ghost kills
        #creates a list and then adds ghost objects to the list depending on the round specified. 
        self.round = 1
        self.ghostKills = 0
        self.ghosts = [Ghost(0), Ghost(1)]
        
        #creates the player object
        self.player = Player()
        
        #creates trees
        self.trees = self.createMap()
        self.setUpMap()
        
        #moves the cursor to the center of the screen. 
        self.win.movePointer(0, self.props.getXSize()//2,self.props.getYSize()//2)
        
        #adds the update method for the player and the maingame method for the game into the task manager
        self.taskMgr.add(self.mainGame,"mainGame")
        self.taskMgr.add(self.player.updatePlayer, "updatePlayer")
        
        #if the input is microbit, it will add the updateMicrobit method as well
        if self.inputMode == "microbit":    
            self.taskMgr.add(self.updateMicrobit, "updateMicrobit")
        
        
        #iterates through the list of ghosts in the game
        #adds each updateGhost method of each ghost into the task manager
        #for each ghost, it will tell the event object to accept collision events between this ghost and every other ghost in the list
        #also adds each event name into an event list, which makes it easier to clean up when the player dies
        for num in range(len(self.ghosts)):
            self.taskMgr.add(self.ghosts[num].update, f"{num}updateGhost")
            for ghost in self.ghosts:
                if ghost != self.ghosts[num]:
                    self.events.accept(f"{num}ghostCollNode-into-{ghost.ghostNumber}ghostCollNode", self.events.ghostToGhost, [num, ghost.ghostNumber])
                    self.events.ghostToGhostEventList.append("{num}ghostCollNode-into-{ghost.ghostNumber}ghostCollNode")
                    self.events.accept(f"{num}ghostCollNode-out-{ghost.ghostNumber}ghostCollNode", self.events.ghostToGhost, [num, -1])
                    self.events.ghostToGhostEventList.append("{num}ghostCollNode-out-{ghost.ghostNumber}ghostCollNode")
        #creates the roundSpawnTimer, which is a timer object that is used to determine how often and when the ghosts spawn in.
        self.roundSpawnTimer = Timer()
        self.roundSpawnTimer.setTimer(0)
        
        #creates the roundCounter, which is a DirectLabel object that displays the current round
        self.roundCounter = DirectLabel(text = f"Round {self.round}", scale = 0.15, pos = (-1.45,0,-0.85), text_font = self.gameFont, relief = None, text_fg = (1,0,0,1), frameColor = (0,0,0,1))
        return task.done
    
    def transitionDeathToGame(self):
        '''
        This method is for transitioning the death screen back into the game, it is called when the user clicks the play again button on the you died screen.
        It removes everything on the gui from before and then it adds the setUpMainGame task to the taskManager.
        
        Parameters
        ----------------------------------------------------
        None
        
        Returns
        ----------------------------------------------------
        None
        
'''
        for directGui in self.gui.values():
            directGui.destroy()
        self.taskMgr.add(self.setUpMainGame, "setUpMainGame")
    
    def transitionGameToDeath(self):
        '''
        This is a method responsible for transitioning the game to death. It cleans up the scene from the game and then creates the
        new gui that is displayed in the death screen. There are many things that need to be done, it needs to remove all the objects that
        were previously on the scene graph such as the trees, the floor, and the ghosts. It also needs to remove the collision solids from the collision traverser
        and clean up the events. Then it needs to create the new gui that is displayed on the screen. 
        
        Parameters
        ----------------------------------------------------
        None
        
        Returns
        ----------------------------------------------------
        None

'''
        #Goes into the ghostCollision eventlist and tells the event handler to ignore all of these events
        for event in self.events.ghostToGhostEventList:
            self.events.ignore(event)
        
        #every ghost in self.ghosts needs to be destroyed if it has not been already.
        for ghost in self.ghosts:
            if ghost != None:
                ghost.destruct()
        
        #removes all collision solids from the collision traverser
        #removes any node parented to gameRoot (trees, the floor)
        #removes any nodes below the cam
        #removes the roundcounter
        self.cTrav.clearColliders()
        self.gameRoot.node().removeAllChildren()
        self.cam.node().removeAllChildren()
        self.roundCounter.destroy()
        
        #changes the cursor from hidden to visible
        self.windowProps.updateMouseView()
        self.win.requestProperties(self.windowProps)
        self.props = self.win.getProperties()
        #creates the gui for the death screen
        self.gui = {"replay": DirectButton(text = "Play Again", scale = 0.1, pos = (0,0,-0.5), command = self.transitionDeathToGame, sortOrder = 10, text_font = self.gameFont, relief = None, text_fg = (1,1,1,1)),
                         "quit": DirectButton(text = "Quit", scale = 0.1, command = self.gameQuit, pos = (-1.5,0,-0.75), sortOrder = 9, text_font = self.gameFont, relief = None, text_fg = (1,1,1,1)),
                         "score": DirectLabel(text = f"You survived {self.round-1} rounds!", scale = 0.2, sortOrder = 8, pos = (0,0,0.3), text_font = self.gameFont, relief = None, text_fg = (1,0,0,1)),
                         "bloodFilter": OnscreenImage(image = r"assets/bloodSplatterThree.png", scale = (1.7778,1,1)),
                         "kills" : DirectLabel(text = f"You killed {self.ghostKills} zombies!", scale = 0.2, sortOrder = 7, pos = (0,0,0), text_font = self.gameFont, relief = None, text_fg = (1,0,0,1))}
        #makes the image transparent
        self.gui["bloodFilter"].setTransparency(TransparencyAttrib.MAlpha)
        
        #removes the mainGame task from the taskManager
        #if the player kills all ghosts just before it dies, it will add the round setup task to the task manager, I have not experienced this glitch
        #but the if statement is to prevent it from happening at all.
        self.taskMgr.remove("mainGame")
        if self.taskMgr.hasTaskNamed("roundSetup"):
            self.taskMgr.remove("roundSetup")

    def gameQuit(self):
        '''
        This method is the gameQuit method, it is used to exit the game. It first saves the current settings and configurations of the game
        such as the sensitivity or the input. It then tries to close the connection to the microbit, if there is no microbit to close
        the connection with, it moves on and calls sys.exit() which exits panda3d.
        
        Parameters
        ----------------------------------------------------
        None
        
        Returns
        ----------------------------------------------------
        None
'''
        self.settings.saveSettings()
        try:
            self.microbit.closeConnection()
        except:
            pass
        sys.exit()
        
    def mainGame(self, task):
        '''
        Main game method that is called when the game is running. It constantly updates the delta time (change in time from last frame),
        then it checks if any ghosts are still alive, if there isn't any more ghost's alive it will call the setUpRound function which
        will set up the new round.
        
        Parameters
        ----------------------------------------------------
        task: task object from direct.task
        
        Returns
        ----------------------------------------------------
        returns task.cont which indicates the task is finished
'''
        #settings deltaTime
        self.dt = globalClock.getDt()
        
        #checkGhosts is a boolean variable
        #iterates through self.ghosts and if there is a single ghost that is still alive, it will break from the loop
        #and set checkGhosts to True
        checkGhosts = False
        for ghost in self.ghosts:
            if ghost != None:
                checkGhosts = True
                break
            
        #if there wasn't any ghosts alive and the game is not currently setting up rounds then increase the round
        if not checkGhosts and not self.taskMgr.hasTaskNamed("roundSetup"):
            self.round += 1
            #adds the setupround task but only performs the task 2 seconds later.
            self.taskMgr.doMethodLater(2,self.setUpRound,"roundSetup")
            
        return task.cont
    
    def setUpRound(self, task):
        '''
        This task is responsible for setting up the next round. It works similarily to the setUpMainGame task, except it
        doesn't tear the whole scene down, instead it modifies some variable and adjusts for the new round and new amount of ghosts.
        
        It recreates the list of ghost objects, redos the event lists for each of them. It also recreates the event list
        for checking if the ghost is hit by the axe, if the ghost is hitting the player, and which ghosts are colliding with eachother.
        Then it resets the round spawn timer.
        
        Parameters
        ----------------------------------------------------
        task: task object from direct.task
        
        Returns
        ----------------------------------------------------
        Returns task.done which indicates the task is finished and can be removed from the task manager.
'''
        #resets the lists for the ghosts and their event lists in the Handler() class
        #Tells the handler to ignore every ghostToGhost event then resets the ghosttoghosts event list
        self.ghosts = []
        self.events.ghostAxeList = []
        self.events.ghostHitList = []
        self.events.ghostToGhostColliding = []
        for event in self.events.ghostToGhostEventList:
            self.events.ignore(event)
        self.events.ghostToGhostEventList = []
        
        #recreates the ghosts list of ghost objects.
        for num in range(self.round+1):
            self.ghosts.append(Ghost(num))
            
        #adds all the update tasks for each ghost in ghosts list
        #also adds the correct amount of indices with default values for ghostAxeList, ghostHitList and ghostToGhostColliding
        for num in range(len(self.ghosts)):
            self.taskMgr.add(self.ghosts[num].update, f"{num}updateGhost")
            self.events.ghostAxeList.append(False)
            self.events.ghostHitList.append([False,Timer()])
            self.events.ghostToGhostColliding.append(-1)
            for ghost in self.ghosts:
                #tells the event handler class to accept events that are thrown when ghosts collide with eachother
                if ghost != self.ghosts[num]:
                    self.events.accept(f"{num}ghostCollNode-into-{ghost.ghostNumber}ghostCollNode", self.events.ghostToGhost, [num, ghost.ghostNumber])
                    self.events.ghostToGhostEventList.append("{num}ghostCollNode-into-{ghost.ghostNumber}ghostCollNode")
                    self.events.accept(f"{num}ghostCollNode-out-{ghost.ghostNumber}ghostCollNode", self.events.ghostToGhost, [num, ghost.ghostNumber])
                    self.events.ghostToGhostEventList.append("{num}ghostCollNode-out-{ghost.ghostNumber}ghostCollNode")
        #resets the roundspawn timer
        self.roundSpawnTimer.setTimer(0)
        
        #resets the roundcounter
        self.roundCounter.setText(f"Round {self.round}")
        return task.done
    
    def createMap(self):
        '''
        This method is for creating the map, it loads all of the tree NodePaths into a list.
        Parameters
        ----------------------------------------------------
        None
        
        Returns
        ----------------------------------------------------
        Returns a list of NodePaths objects
         
'''
        trees = [self.loader.loadModel(r"assets/treeOne.x"),
                      self.loader.loadModel(r"assets/treeTwo.x"),
                      self.loader.loadModel(r"assets/treeTwo.x"),
                      self.loader.loadModel(r"assets/treeTwo.x"),
                      self.loader.loadModel(r"assets/treeOne.x"),
                      self.loader.loadModel(r"assets/treeOne.x"),
                      self.loader.loadModel(r"assets/treeTwo.x")]
        
        for num in range(27):
            if num == 4 or num == 13:
                trees.append(self.loader.loadModel(r"assets/treeOne.x"))
                trees.append(self.loader.loadModel(r"assets/treeTwo.x"))
                trees.append(self.loader.loadModel(r"assets/treeTwo.x"))
                trees.append(self.loader.loadModel(r"assets/treeTwo.x"))
                trees.append(self.loader.loadModel(r"assets/treeOne.x"))
            else:
                trees.append(self.loader.loadModel(r"assets/treeOne.x"))
                trees.append(self.loader.loadModel(r"assets/treeTwo.x"))
                trees.append(self.loader.loadModel(r"assets/treeTwo.x"))
                trees.append(self.loader.loadModel(r"assets/treeTwo.x"))
                trees.append(self.loader.loadModel(r"assets/treeOne.x"))
                trees.append(self.loader.loadModel(r"assets/treeOne.x"))
                trees.append(self.loader.loadModel(r"assets/treeTwo.x"))
        return trees

    def setUpMap(self):
        '''
        This method takes all the trees in self.trees and sets them up in the scene
        
        It inserts every tree into the scene graph as a child of the gameRoot NodePath.
        Then it sets each ones textures, rotates it (the models come by default as sideways), then calls set light
        on each of the trees. Setlight indicates that this object will be affected by the light object.
        
        Parameters
        ----------------------------------------------------
        None
        
        Returns
        ----------------------------------------------------
        None

'''
        for tree in self.trees:
            tree.reparentTo(self.gameRoot)
            tree.setTexture(self.textures)
            tree.setHpr(0,90,0)
            tree.setLight(self.pLight)
            tree.setLight(self.aLight)
            
        self.trees[0].setPos(-61,-34,-0.5)
        self.trees[1].setPos(-62,-30,-0.5)
        self.trees[2].setPos(-59,-28,-0.5)
        self.trees[3].setPos(-62,-26,-0.5)
        self.trees[4].setPos(-58.5,-27,-0.5)
        self.trees[5].setPos(-62,-25,-0.5)
        self.trees[6].setPos(-59,-23,-0.5)
        
        self.trees[7].setPos(-61,-21,-0.5)
        self.trees[8].setPos(-62,-17,-0.5)
        self.trees[9].setPos(-59,-15,-0.5)
        self.trees[10].setPos(-62,-13,-0.5)
        self.trees[11].setPos(-58.5,-14,-0.5)
        self.trees[12].setPos(-62,-12,-0.5)
        self.trees[13].setPos(-59,-10,-0.5)
        
        self.trees[14].setPos(-61,-8,-0.5)
        self.trees[15].setPos(-62,-4,-0.5)
        self.trees[16].setPos(-59,-2,-0.5)
        self.trees[17].setPos(-62,0,-0.5)
        self.trees[18].setPos(-58.5,-1,-0.5)
        self.trees[19].setPos(-62,1,-0.5)
        self.trees[20].setPos(-59,3,-0.5)
        
        self.trees[21].setPos(-61,5,-0.5)
        self.trees[22].setPos(-62,9,-0.5)
        self.trees[23].setPos(-59,11,-0.5)
        self.trees[24].setPos(-62,13,-0.5)
        self.trees[25].setPos(-58.5,12,-0.5)
        self.trees[26].setPos(-62,14,-0.5)
        self.trees[27].setPos(-59,16,-0.5)
        
        self.trees[28].setPos(-61,18,-0.5)
        self.trees[29].setPos(-62,22,-0.5)
        self.trees[30].setPos(-59,24,-0.5)
        self.trees[31].setPos(-62,26,-0.5)
        self.trees[32].setPos(-58.5,25,-0.5)
        self.trees[33].setPos(-62,27,-0.5)
        self.trees[34].setPos(-59,29,-0.5)
        
        self.trees[35].setPos(-61,31,-0.5)
        self.trees[36].setPos(-62,35,-0.5)
        self.trees[37].setPos(-59,37,-0.5)
        self.trees[38].setPos(-62,39,-0.5)
        self.trees[39].setPos(-58.5,38,-0.5)
    
        #forward side
        self.trees[40].setPos(-53,38,-0.5)
        self.trees[41].setPos(-51,39,-0.5)
        self.trees[42].setPos(-49,36,-0.5)
        self.trees[43].setPos(-42,39,-0.5)
        self.trees[44].setPos(-40,35.5,-0.5)
        self.trees[45].setPos(-45,38,-0.5)
        self.trees[46].setPos(-44,36,-0.5)
        
        self.trees[47].setPos(-40,38,-0.5)
        self.trees[48].setPos(-38,39,-0.5)
        self.trees[49].setPos(-36,36,-0.5)
        self.trees[50].setPos(-29,39,-0.5)
        self.trees[51].setPos(-27,35.5,-0.5)
        self.trees[52].setPos(-32,38,-0.5)
        self.trees[53].setPos(-31,36,-0.5)
        
        self.trees[54].setPos(-27,38,-0.5)
        self.trees[55].setPos(-25,39,-0.5)
        self.trees[56].setPos(-23,36,-0.5)
        self.trees[57].setPos(-16,39,-0.5)
        self.trees[58].setPos(-13,35.5,-0.5)
        self.trees[59].setPos(-19,38,-0.5)
        self.trees[60].setPos(-17.5,36,-0.5)
        
        self.trees[61].setPos(-14,38,-0.5)
        self.trees[62].setPos(-12,39,-0.5)
        self.trees[63].setPos(-10,36,-0.5)
        self.trees[64].setPos(-3,39,-0.5)
        self.trees[65].setPos(0,35.5,-0.5)
        self.trees[66].setPos(-6,38,-0.5)
        self.trees[67].setPos(-4.5,36,-0.5)
        
        self.trees[68].setPos(-1,38,-0.5)
        self.trees[69].setPos(1,39,-0.5)
        self.trees[70].setPos(3,36,-0.5)
        self.trees[71].setPos(10,39,-0.5)
        self.trees[72].setPos(13,35.5,-0.5)
        self.trees[73].setPos(7,38,-0.5)
        self.trees[74].setPos(8.5,36,-0.5)
        
        self.trees[75].setPos(12,38,-0.5)
        self.trees[76].setPos(14,39,-0.5)
        self.trees[77].setPos(16,36,-0.5)
        self.trees[78].setPos(23,39,-0.5)
        self.trees[79].setPos(26,35.5,-0.5)
        self.trees[80].setPos(20,38,-0.5)
        self.trees[81].setPos(21.5,36,-0.5)
        
        self.trees[82].setPos(25,38,-0.5)
        self.trees[83].setPos(27,39,-0.5)
        self.trees[84].setPos(29,36,-0.5)
        self.trees[85].setPos(36,39,-0.5)
        self.trees[86].setPos(39,35.5,-0.5)
        self.trees[87].setPos(33,38,-0.5)
        self.trees[88].setPos(34.5,36,-0.5)
        
        self.trees[89].setPos(38,38,-0.5)
        self.trees[90].setPos(40,39,-0.5)
        self.trees[91].setPos(42,36,-0.5)
        self.trees[92].setPos(49,39,-0.5)
        self.trees[93].setPos(52,35.5,-0.5)
        self.trees[94].setPos(46,38,-0.5)
        self.trees[95].setPos(47.5,36,-0.5)
        
        #right side
        self.trees[96].setPos(51,18,-0.5)
        self.trees[97].setPos(52,22,-0.5)
        self.trees[98].setPos(49,24,-0.5)
        self.trees[99].setPos(52,26,-0.5)
        self.trees[100].setPos(48.5,25,-0.5)
        self.trees[101].setPos(52,27,-0.5)
        self.trees[102].setPos(49,29,-0.5)
        
        self.trees[103].setPos(51,-34,-0.5)
        self.trees[104].setPos(52,-30,-0.5)
        self.trees[105].setPos(49,-28,-0.5)
        self.trees[106].setPos(52,-26,-0.5)
        self.trees[107].setPos(48.5,-27,-0.5)
        self.trees[108].setPos(52,-25,-0.5)
        self.trees[109].setPos(49,-23,-0.5)
        
        self.trees[110].setPos(51,-21,-0.5)
        self.trees[111].setPos(52,-17,-0.5)
        self.trees[112].setPos(49,-15,-0.5)
        self.trees[113].setPos(52,-13,-0.5)
        self.trees[114].setPos(48.5,-14,-0.5)
        self.trees[115].setPos(52,-12,-0.5)
        self.trees[116].setPos(49,-10,-0.5)
        
        self.trees[117].setPos(51,-8,-0.5)
        self.trees[118].setPos(52,-4,-0.5)
        self.trees[119].setPos(49,-2,-0.5)
        self.trees[120].setPos(52,0,-0.5)
        self.trees[121].setPos(48.5,-1,-0.5)
        self.trees[122].setPos(52,1,-0.5)
        self.trees[123].setPos(49,3,-0.5)
        
        self.trees[124].setPos(51,5,-0.5)
        self.trees[125].setPos(52,9,-0.5)
        self.trees[126].setPos(49,11,-0.5)
        self.trees[127].setPos(52,13,-0.5)
        self.trees[128].setPos(48.5,12,-0.5)
        self.trees[129].setPos(52,14,-0.5)
        self.trees[130].setPos(49,16,-0.5)
        
        self.trees[131].setPos(51,31,-0.5)
        self.trees[132].setPos(52,35,-0.5)
        self.trees[133].setPos(49,37,-0.5)
        self.trees[134].setPos(52,39,-0.5)
        self.trees[135].setPos(48.5,38,-0.5)
        
        #backward side
        self.trees[136].setPos(-53,-32,-0.5)
        self.trees[137].setPos(-51,-33,-0.5)
        self.trees[138].setPos(-49,-30,-0.5)
        self.trees[139].setPos(-42,-33,-0.5)
        self.trees[140].setPos(-40,-29.5,-0.5)
        self.trees[141].setPos(-45,-32,-0.5)
        self.trees[142].setPos(-44,-30,-0.5)
        
        self.trees[143].setPos(-40,-32,-0.5)
        self.trees[144].setPos(-38,-33,-0.5)
        self.trees[145].setPos(-36,-30,-0.5)
        self.trees[146].setPos(-29,-33,-0.5)
        self.trees[147].setPos(-27,-29.5,-0.5)
        self.trees[148].setPos(-32,-32,-0.5)
        self.trees[149].setPos(-31,-30,-0.5)
        
        self.trees[150].setPos(-27,-32,-0.5)
        self.trees[151].setPos(-25,-33,-0.5)
        self.trees[152].setPos(-23,-30,-0.5)
        self.trees[153].setPos(-16,-33,-0.5)
        self.trees[154].setPos(-13,-29.5,-0.5)
        self.trees[155].setPos(-19,-32,-0.5)
        self.trees[156].setPos(-17.5,-30,-0.5)
        
        self.trees[157].setPos(-14,-32,-0.5)
        self.trees[158].setPos(-12,-33,-0.5)
        self.trees[159].setPos(-10,-30,-0.5)
        self.trees[160].setPos(-3,-33,-0.5)
        self.trees[161].setPos(0,-29.5,-0.5)
        self.trees[162].setPos(-6,-32,-0.5)
        self.trees[163].setPos(-4.5,-30,-0.5)
        
        self.trees[164].setPos(-1,-32,-0.5)
        self.trees[165].setPos(1,-33,-0.5)
        self.trees[166].setPos(3,-30,-0.5)
        self.trees[167].setPos(10,-33,-0.5)
        self.trees[168].setPos(13,-29.5,-0.5)
        self.trees[169].setPos(7,-32,-0.5)
        self.trees[170].setPos(8.5,-30,-0.5)
        
        self.trees[171].setPos(12,-32,-0.5)
        self.trees[172].setPos(14,-33,-0.5)
        self.trees[173].setPos(16,-30,-0.5)
        self.trees[174].setPos(23,-33,-0.5)
        self.trees[175].setPos(26,-29.5,-0.5)
        self.trees[176].setPos(20,-32,-0.5)
        self.trees[177].setPos(21.5,-30,-0.5)
        
        self.trees[178].setPos(25,-32,-0.5)
        self.trees[179].setPos(27,-33,-0.5)
        self.trees[180].setPos(29,-30,-0.5)
        self.trees[181].setPos(36,-33,-0.5)
        self.trees[182].setPos(39,-29.5,-0.5)
        self.trees[183].setPos(33,-32,-0.5)
        self.trees[184].setPos(34.5,-30,-0.5)
        
        self.trees[185].setPos(38,-32,-0.5)
        self.trees[186].setPos(40,-33,-0.5)
        self.trees[187].setPos(42,-30,-0.5)
        self.trees[188].setPos(49,-33,-0.5)
        self.trees[189].setPos(52,-29.5,-0.5)
        self.trees[190].setPos(46,-32,-0.5)
        self.trees[191].setPos(47.5,-30,-0.5)

game = MyGame()

game.run() 